#!/bin/bash
#
# Shell based ssh_executor
#
# SSH executor is the most useful kind of executors for APIServers. This kind 
# of executor interface it just executes given commands to the specified 
# remote host.
#
# Infrastructure parameters
#
# user: username of the remote user
# host: SSH remote host address
# password: SSH username' password
# sshkey: SSH private key path used to passwordlessy connect remote host
#
# One of the two parameters: password, sshkey has to be specified sshkey path
# has the priority

# tools functions
. tools.sh

# logging import and customisation
LOG_FILE=sh_ssh_executor.log
LOG_LEVEL=DEBUG
. logging.sh $LOG_FILE $LOG_LEVEL

# Check for compatibility issues before start the server is also may produce
# several aliases used by next includes (do not move this line)
check_compatibility
# EI Specific compatibility check
EXPECT=$(which expect)
[ "$EXPECT" = "" ] &&\
  log ERROR "Executor interface $(basename $0), requires expect" &&\
  exit 1

# database functions
. fgdb.sh

# tasks functions
. tasks.sh

# APIServer configurations, see shAPIerver.conf
. config.sh

# queue functions
.  queue.sh

#
# Handlers
#

# Interruption; <ctrl-c>
int_handler() {
  log WARN "User interruption detected"
  status="ABORTED"
  target_status="INTERRUPTED"
  exit 0
}
trap int_handler INT KILL

# Exit 
exit_handler() {
  log INFO "Terminating bare execution on task_id: $task_id"
  update_queue_record $task_id || exit 1
  cleanup_temp
}
trap exit_handler EXIT

# Error
error_handler() {
  log ERROR "Script error occurred"
  status="ABORTED"
  target_status="ERRORED"
  exit 1
}
trap error_handler ERR

#
# Functions
#

#
# SH SSH Executor Interface code
#

# Queue task_id
task_id=$1
verify_queued_task
[ $? -ne 0 ] &&\
  log debug "Task '"${task_id}"' verification failed" &&\
  exit 1;

# Retrieve queue record
case $action in
  "SUBMIT")
  # Job description parameter and file presence
  job_desc=$(cat $submit_json |\
             jq '.application.parameters[]|select(.param_name=="jobdesc")' |\
             jq -r .param_value)
  [ "${job_desc}" = "" ] &&\
    status="ABORTED" &&\
    log ERROR "No job description specified for task id: '"$task_id"' with action: '"$action"'" &&\
    exit 1
  [ ! -f $action_info_path"/"$job_desc ] &&\
    status="ABORTED" &&\
    log ERROR "No job description: '"$action_info_path"/"$job_desc"' available for task id: '"$task_id"' with action: '"$action"'" &&\
    exit 1
  # Task arguments
  TASK_ARGS=($(cat $submit_json | jq .arguments[]; ))
  # Go to the action_info_path
  BARE_EXE_INFO=$action_info_path/.sh_bare_executor
  touch $BARE_EXE_INFO
  # Extract action
  SHBE_EXECUTABLE=$(cat $action_info_path"/"$job_desc |\
                    grep -i "^executable" |\
                    awk -F'=' '{ print $2 }' |\
                    xargs echo)
  SHBE_ARGUMENTS=$(cat $action_info_path"/"$job_desc |\
                    grep -i "^arguments" |\
                    awk -F'=' '{ print $2 }' |\
                    xargs echo)" "${TASK_ARGS[@]}
  SHBE_STDOUT=$(cat $action_info_path"/"$job_desc |\
                    grep -i "^stdout" |\
                    awk -F'=' '{ print $2 }' |\
                    xargs echo)
  [ "$SHBE_STDOUT" = "" ] &&\
    SHBE_STDOUT=.stdout
  SHBE_STDERR=$(cat $action_info_path"/"$job_desc |\
                    grep -i "^stderr" |\
                    awk -F'=' '{ print $2 }' |\
                    xargs echo)
  [ "$SHBE_STDERR" = "" ] &&\
    SHBE_STDERR=.stderr
  # Output files are in the form (f1, f2, ... fn)
  SHBE_OUTFILES_VAL=$(cat $action_info_path"/"$job_desc |\
                    grep -i "^output_files" |\
                    awk -F'=' '{ print $2 }' |\
                    xargs echo)
  eval SHBE_OUTFILES"="$SHBE_OUTFILES_VAL
  log DEBUG "Job description"
  log DEBUG "\texecutable=$SHBE_EXECUTABLE"
  log DEBUG "\targuments=$SHBE_ARGUMENTS"
  log DEBUG "\toutput=$SHBE_STDOUT"
  log DEBUG "\terror=$SHBE_STDERR"
  log DEBUG "\toutput_files=$SHBE_OUTFILES_VAL"
  # Infrastructure parameters
  get_temp INFRA_PARAMS
  $(infra_parameters > $INFRA_PARAMS) ||\
    (log ERROR "Unable to get infrastructure parameters" &&\
    STATUS="ABORTED" &&\
    exit 1;)
  infra_host=$(cat $INFRA_PARAMS | grep ^host | awk -F'\t' '{ print $2 }')
  [ "$infra_host" = "" ] &&\
    log ERROR "Missing SSH host address for task: '"${task_id}"'" &&\
    exit 1
  infra_user=$(cat $INFRA_PARAMS | grep ^user | awk -F'\t' '{ print $2 }')
  [ "$infra_user" = "" ] &&\
    log ERROR "Missing SSH user name for task: '"${task_id}"'" &&\
    exit 1
  infra_password=$(cat $INFRA_PARAMS | grep ^password | awk -F'\t' '{ print $2 }')
  infra_sshkey=$(cat $INFRA_PARAMS | grep ^usesshkeyr | awk -F'\t' '{ print $2 }')
  if  [ "$infra_password" = "" -a\
        "$infra_sshkey" = "" ]; then
    [ "$infra_password" = "" ] &&\
      log ERROR "Missing SSH password for task: '"${task_id}"'" &&\
    [ "$infra_sshkey" = "" ] &&\
      log ERROR "Missing SSH key for task: '"${task_id}"'" &&\
    exit 1
  fi
  rm_temp INFRA_PARAMS
  # Execute the requested job
  cd $action_info_path
  # Prepare the sandbox archive
  get_temp IOSANDBOX
  IOSANDBOX_FNAME=$(basename $IOSANDBOX)
  tar cvfz $IOSANDBOX .
  if [ "$infra_sshkey" = "" ]; then
    log DEBUG "Starting SSH execution using keyfile path: '"$infra_sshkey"'"
    # Create remote sandbox dir
    REMOTE_IOSANDBOX=$(ssh -i $infra_sshkey $infra_user@$infra_host "mktemp")
    # Transfer the sandbox
    log DEBUG "Transger IOSANDBOX('"${IOSANDBOX}"->"${$REMOTE_IOSANDBOX/$IOSANDBOX_FNAME}"'"
    scp -i $infra_sshkey $IOSANDBOX $infra_user@$infra_host:$REMOTE_IOSANDBOX/$IOSANDBOX_FNAME
    # Create remote execution script
    EXECUTOR_PID=$$
    cat >sh_ssh_executor_script.sh <<EOF
#!/bin/bash
# Script automatically generated by sh_ssh_executor
cd ${REMOTE_IOSANDBOX}
tar xvfz ${IOSANDBOX_FNAME}
$SHBE_EXECUTABLE $SHBE_ARGUMENTS 2>$SHBE_STDERR >$SHBE_STDOUT &
SHBE_PID=$!
echo "task_id=${SHBE_PID}" >> ${BARE_EXE_INFO}
echo "executor_pid=${EXECUTOR_PID}" >> ${BARE_EXE_INFO}
wait $SHBE_PID
echo "end_ts="$(ts) >> $BARE_EXE_INFO
SHBE_RET=$?
echo "return_code=${SHBE_RET}" >> $BARE_EXE_INFO
cd - >/dev/null
EOF
    # Transfer the sandbox
    scp -i $infra_sshkey sh_ssh_executor_script.sh $infra_user@$infra_host:$REMOTE_IOSANDBOX/sh_ssh_executor_script.sh
    # Execute the command
    log DEBUG "Executing remote ssh command: \"$SHBE_EXECUTABLE $SHBE_ARGUMENTS 2>$SHBE_STDERR >$SHBE_STDOUT\""
    ssh -i $infra_sshkey $infra_user@$infra_host "\
      cd $REMOTE_IOSANDBOX &&\
      chmod +x sh_ssh_executor_script.sh &&\
      ./sh_ssh_executor_script.sh &"
    # Retrieve the PID
    status="RUNNING"
    target_status="RUNNING"
    update_queue_record $task_id || exit 1
    # Wait execution completion
    log DEBUG "Waiting for execution completion"
    while true; do
      scp -i $infra_user@$infra_host:$BARE_EXE_INFO $BARE_EXE_INFO
      end_ts=$(cat $BARE_EXE_INFO | grep ^end_ts | awk -F'=' '{ print $2 }')
      return_code=$(cat $BARE_EXE_INFO | grep ^return_code | awk -F'=' '{ print $2 }')
      if [ "$end_ts" -ne 0 -a\
           "$return_code" != "" ] &&\
        break ||\
        sleep 5
    done
    # Transfer
    scp -rf $infra_user@$infra_host:$REMOTE_IOSANDBOX/ .
    ssh -i $infra_sshkey $infra_user@$infra_host "rm -rf $REMOTE_IOSANDBOX"
  else
    # Transfer the sandbox
    log DEBUG "Executing using password not yet implemented"
    status="ABORTED"
    target_status="ABORTED"
    exit 1
  fi
  rm_temp IOSANDBOX
  [ $return_code -eq 0 ] &&\
    status="DONE" &&\
    target_status="DONE" ||\
    (status="ABORTED" &&\
    target_status="ABORTED";)
  finalize_task || exit 1
  ;;
  "STATUS")
  log DEBUG "Not yet implemented action: '"$action"' for task_id: '"$task_id"'"
  ;;
  "KILL")
  log DEBUG "Not yet implemented action: '"$action"' for task_id: '"$task_id"'"
  ;;
  *)
  log ERROR "Unknown action: '"$action"' for task_id: '"$task_id"'"
  exit 1
  ;;
esac
